import random
import utils

class Pizza:
    def __init__(self, customers, ingredients):
        self.customers = customers
        self.ingredients = ingredients
        # Generate a initial solution with random ingredients
        self.solution = random.randint(0, 2**len(ingredients) - 1)
        self.score = 0

    def get_solution(self):
        """
        Returns a set of ingredints that are in the solution
        TODO: Check if a list is more appropriate
        """
        return {self.ingredients[i] for i in range(len(self.ingredients)) if self.solution & utils.BIT(i)}

def eval_function(pizza): 
    """
    Evaluation function for the pizza problem
    pizza: Solution to be evaluated

    Returns the number of satisfied customers
    """
    pizza.score = 0
    for client in pizza.customers:
        # TODO: find a more efficient way to evaluate the solution without generating the set
        if ((client.likes & pizza.get_solution()) == client.likes) and ((client.dislikes & pizza.get_solution()) == set()):
            pizza.score += 1
    return pizza.score

def generate_neighbors(pizza):
    """
    Generates all neighbors of a given solution
    Neighbors are generated by adding or removing one ingredient from the solution
    pizza: Current solution

    Returns the list of neighbors of the given solution
    """
    neighbors = set()

    # add ingredient
    for i in range(len(pizza.ingredients)):
        neighbor = Pizza(pizza.customers, pizza.ingredients)
        neighbor.solution = utils.enable_bit(pizza.solution, i)
        if neighbor.solution != pizza.solution:
            neighbors.add(neighbor)

    # remove ingredient
    for i in range(len(pizza.ingredients)):
        neighbor = Pizza(pizza.customers, pizza.ingredients)
        neighbor.solution = utils.disable_bit(pizza.solution, i)
        if neighbor.solution != pizza.solution:
            neighbors.add(neighbor)

    return list(neighbors)

def hill_climbing(f, x0):
    """
    Hill climbing algorithm
    Stop criteria: 1000 iterations without improvement
    f: evaluation function
    x0: initial solution

    Returns the best solution found
    """
    x = x0
    best_eval = f(x)

    # it = 0
    no_improvement = 0
    while no_improvement < 1000:
        no_improvement += 1
        neighbors = generate_neighbors(x)       # generate current solution neighbors
        best_neighbor = max(neighbors, key=f)   # find neighbor with highest fitness value
        # print(f"{it}: {x.get_solution()} -> {best_neighbor.get_solution()} ({best_neighbor.score})")
        neighbor_eval = f(best_neighbor)
        if neighbor_eval > best_eval:           # if the best neighbor is better than the current solution
            no_improvement = 0
            x = best_neighbor
            best_eval = neighbor_eval
            # print(f"New best solution: {x.get_solution()} ({x.score})")
        # it += 1

    return x # return the best solution found
