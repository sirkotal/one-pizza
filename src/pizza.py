import math
import random
import utils

class Pizza:
    def __init__(self, customers, ingredients, eval_function=None):
        """
        Initializes a pizza object and updates the bitstrings for customers likes and dislikes

        Args:
            customers: List of customers
            ingredients: List of ingredients
            eval_function: Evaluation function (default pizza.eval_function)
        """
        self.customers = customers
        self.ingredients = ingredients
        # Generate a initial solution with random ingredients
        self.solution = random.randint(0, 2**len(ingredients) - 1)
        self.score = 0
        self.eval_solution = eval_function if eval_function is not None else self.eval_solution

        # Update the bitstrings for liked and disliked ingredients
        for customer in customers:
            for likes in customer.likes:
                customer.likes_bitstring |= utils.BIT(ingredients.index(likes))
            for dislikes in customer.dislikes:
                customer.dislikes_bitstring |= utils.BIT(ingredients.index(dislikes))

    def get_solution(self):
        """
        Returns a list of ingredients that are in the solution
        """
        return [self.ingredients[i] for i in range(len(self.ingredients)) if self.solution & utils.BIT(i)]

    def eval_solution(self, solution=None):
        """
        Default evaluation function for the pizza problem
        If a solution is provided, it evaluates the given solution
        Otherwise, it evaluates the current solution and updates the score

        Args:
            solution: Solution to be evaluated (default self.solution)

        Returns the number of satisfied customers
        """
        if solution is None:
            solution = self.solution

        score = 0
        for client in self.customers:
            if (client.likes_bitstring & solution) == client.likes_bitstring and (client.dislikes_bitstring & solution) == 0:
                score += 1

        if solution is not None:
            self.score = score
        return score

def get_neighbors(solution, ingredients):
    """
    Generates all neighbors of a given solution
    Neighbors are generated by adding or removing one ingredient from the solution

    Args:
        solution: Current solution
        ingredients: List of ingredients

    Returns a list of neighbors (just solutions)
    """
    neighbors = []

    # add ingredient
    for i in range(len(ingredients)):
        neighbor_solution = utils.enable_bit(solution, i)
        if neighbor_solution != solution:
            neighbors.append(neighbor_solution)

    # remove ingredient
    for i in range(len(ingredients)):
        neighbor_solution = utils.disable_bit(solution, i)
        if neighbor_solution != solution:
            neighbors.append(neighbor_solution)

    return neighbors

def get_best_neighbor(solution, ingredients, f):
    """
    Finds the best neighbor of a given solution

    Args:
        solution: Current solution
        ingredients: List of ingredients
        f: Evaluation function

    Returns the best neighbor found
    """

    best_neighbors = [] ; best_score = -1
    for neighbor in get_neighbors(solution, ingredients):
        score = f(neighbor)
        if score > best_score:
            best_score = score
            best_neighbors = [neighbor]
        elif score == best_score:
            best_neighbors.append(neighbor)

    return random.choice(best_neighbors)

def hill_climbing(pizza, max_iterations=1000, log=False):
    """
    Hill climbing algorithm
    Stop criteria: `max_iterations` iterations without improvement

    Args:
        pizza: initial solution
        max_iterations: maximum number of iterations with no improvement (default 1000)
        log: If True, prints the solution at each iteration

    Returns the best solution found
    """
    x = pizza.solution ; best_eval = pizza.eval_solution(x)

    it = 0 ; no_improvement = 0
    while no_improvement < max_iterations:
        it += 1 ; no_improvement += 1

        best_neighbor = get_best_neighbor(x, pizza.ingredients, pizza.eval_solution)
        neighbor_eval = pizza.eval_solution(best_neighbor)
        if log:
            print(f"{it}: {x} -> {best_neighbor} ({neighbor_eval})")

        # if neighbor is better than current solution
        if neighbor_eval > best_eval:
            no_improvement = 0
            x = best_neighbor ; best_eval = neighbor_eval
            if log:
                print(f"New best solution: {x} ({best_eval})")

    pizza.solution = x
    pizza.score = best_eval

def cooling_schedule(t):
    """
    Cooling schedule for the simulated annealing algorithm
    
    Args:
        t: Current temperature

    Returns the new temperature
    """
    return t * 0.999

def simulated_annealing(pizza, temperature=1000, max_iterations=1000, log=False):
    """
    Simulated annealing algorithm
    The stop criteria is `max_iterations` - iterations without improvement

    Args:
        pizza: initial solution
        temperature: initial temperature (default 1000)
        max_iterations: maximum number of iterations with no improvement (default 1000)
        log: If True, prints the solution at each iteration

    Returns the best solution found
    """
    x = pizza.solution ; curr_eval = pizza.eval_solution(x)

    it = 0 ; no_improvement = 0
    while no_improvement < max_iterations:
        it += 1 ; no_improvement += 1

        temperature = cooling_schedule(temperature)
        rand_neighbor = random.choice(get_neighbors(x, pizza.ingredients)) ; neighbor_eval = pizza.eval_solution(rand_neighbor)
        if log:
            print(f"{it}: {x} -> {rand_neighbor} ({neighbor_eval})")

        if neighbor_eval > curr_eval:             
            no_improvement = 0

            x = rand_neighbor ; curr_eval = neighbor_eval
            if log:
                print(f"New best solution: {x} ({curr_eval})")
        else:
            chance = math.exp(-(curr_eval - neighbor_eval) / temperature) * 100
            prob = random.randint(1, 100)

            if log:
                print(f"{chance}, {prob}")

            if prob <= chance:
                x = rand_neighbor ; curr_eval = neighbor_eval
                if log:
                    print(f"New worse solution: {x} ({curr_eval})")

    pizza.solution = x
    pizza.score = curr_eval

def roulette_wheel_selection(solutions, scores):
    """
    Roulette wheel selection method for genetic algorithm

    Args:
        solutions: List of solutions
        scores: List of scores

    Returns two parents selected by the roulette wheel method
    """
    total_score = sum(scores)
    probabilities = [score / total_score for score in scores] if total_score != 0 else [1 / len(solutions) for _ in solutions]
    return random.choices(solutions, weights=probabilities, k=2)

def tournament_selection(solutions, scores, num_p):
    """
    Tournament selection method for genetic algorithm

    Args:
        solutions: List of solutions
        scores: List of scores
        num_p: Number of participants in the tournament

    Returns two parents selected by the tournament selection method
    """
    num_sol = len(solutions)
    parents = []
    for _ in range(2):
        best_participant = None
        best_score = -1

        for _ in range(num_p):
            participant = random.randint(0, num_sol - 1)
            solution = solutions[participant] ; score = scores[participant]
            if score > best_score and solution not in parents:
                best_participant = participant
                best_score = score
        parents.append(solutions[best_participant])
    return parents

def genetic_algorithm(pizza, num_generations=100, mutation_rate=0.01, selection_method="roulette", tournament_size=4, log=False):
    """
    Genetic algorithm for the pizza problem
    
    Args:
        pizza: Initial solution
        num_generations: Number of generations (default 100)
        mutation_rate: Mutation rate (default 0.01)
        selection_method: Selection method (default roulette)
            - roulette: Roulette wheel selection
            - tournament: Tournament selection
        tournament_size: Tournament size (default 4)
        log: If True, prints the solution at each iteration

    Returns the best solution found
    """
    if selection_method not in ["roulette", "tournament"]:
        raise ValueError("Invalid selection method")

    solutions = get_neighbors(pizza.solution, pizza.ingredients)

    # missing termination criteria -> individual fit enough?
    for gen in range(num_generations):
        scores = [pizza.eval_solution(solution) for solution in solutions]
        if selection_method == "roulette":
            parents = roulette_wheel_selection(solutions, scores)
        else:
            parents = tournament_selection(solutions, scores, tournament_size)

        if log:
            print(f"Generation {gen + 1} -> Parents: {parents}")

        children = crossover(parents)
        mutate(children, mutation_rate)

        if log:
            print(f"Generation {gen + 1} -> New children: {children}")

        solutions += children

    scores = [pizza.eval_solution(solution) for solution in solutions]
    pizza.score = max(scores)
    best_solution = solutions[scores.index(pizza.score)]
    pizza.solution = best_solution

def crossover(parents):
    """
    Crossover method for genetic algorithm

    Args:
        parents: List of two parents (solutions)

    Returns two children generated by the crossover method
    """
    a = parents[0]
    b = parents[1]
    crossover_point = random.randint(1, min(len(bin(a)), len(bin(b))) - 1)

    child_1 = int(bin(a)[:crossover_point] + bin(b)[crossover_point:], 2)
    child_2 = int(bin(b)[:crossover_point] + bin(a)[crossover_point:], 2)
    return [child_1, child_2]

def mutate(children, mutation_rate):
    """
    Mutation method for genetic algorithm

    Args:
        children: List of children (solutions)
        mutation_rate: Mutation rate

    Returns the mutated children
    """
    for child in children:
      for i in range(len(bin(child))):
        if random.random() < mutation_rate:
          child ^= utils.BIT(i)

def tabu_search(pizza, max_iterations=1000, tabu_size=10, neighborhood_size=10, log=False):
    """
    Tabu search algorithm for the pizza problem

    Args:
        pizza: Initial solution
        max_iterations: Maximum number of iterations (default 1000)
        tabu_size: Tabu list size (default 10)
        neighborhood_size: Size of the neighborhood (default 10)
        log: If True, prints the solution at each iteration

    Returns the best solution found
    """
    # current score
    current_solution = pizza.solution
    tabu_list = []

    # first score
    best_solution = current_solution ; best_score = pizza.eval_solution(current_solution)

    for _ in range(max_iterations):
        neighbors = get_neighbors_tabu(current_solution, pizza.ingredients, neighborhood_size)
        best_neighbor = None ; best_neighbor_score = -1

        for neighbor in neighbors:
            # not on tabu or better
            if (neighbor not in tabu_list) or (pizza.eval_solution(neighbor) > best_score):
                score = pizza.eval_solution(neighbor)
                if score > best_neighbor_score:
                    best_neighbor = neighbor
                    best_neighbor_score = score

        if best_neighbor is None:
            break

        current_solution = best_neighbor

        if best_neighbor_score > best_score:
            best_solution = best_neighbor
            best_score = best_neighbor_score

            if log:
                print(f"New best solution: {best_solution} ({best_score})")

        tabu_list.append(best_neighbor)
        if len(tabu_list) > tabu_size:
            tabu_list.pop(0)

    pizza.solution = best_solution
    pizza.score = best_score

def generate_neighbor(solution, ingredients):
    """
    Generates a random neighbor of a given solution
    Only used in tabu search

    Args:
        solution: Current solution
        ingredients: List of ingredients

    Returns a random neighbor
    """
    ingredient_index = random.randint(0, len(ingredients) - 1)
    return solution ^ utils.BIT(ingredient_index)

def get_neighbors_tabu(solution, ingredients, neighborhood_size):
    """
    Generates a list of neighbors of a given solution
    Only used in tabu search

    Args:
        solution: Current solution
        ingredients: List of ingredients
        neighborhood_size: Size of the neighborhood
        
    Returns a list of neighbors
    """
    neighbors = []
    for _ in range(neighborhood_size):
        neighbor = generate_neighbor(solution, ingredients)
        neighbors.append(neighbor)
    return neighbors
