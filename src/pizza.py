import math
import random
import utils

class Pizza:
    def __init__(self, customers, ingredients):
        """
        Initializes a pizza object and updates the bitstrings for customers likes and dislikes

        Args:
            customers: List of customers
            ingredients: List of ingredients
        """
        self.customers = customers
        self.ingredients = ingredients
        # Generate a initial solution with random ingredients
        self.solution = random.randint(0, 2**len(ingredients) - 1)
        self.score = 0

        # Update the bitstrings for liked and disliked ingredients
        for customer in customers:
            for likes in customer.likes:
                customer.likes_bitstring |= utils.BIT(ingredients.index(likes))
            for dislikes in customer.dislikes:
                customer.dislikes_bitstring |= utils.BIT(ingredients.index(dislikes))

    def get_solution(self):
        """
        Returns a list of ingredints that are in the solution
        """
        return [self.ingredients[i] for i in range(len(self.ingredients)) if self.solution & utils.BIT(i)]

def eval_function(pizza): 
    """
    Evaluation function for the pizza problem

    Args:
        pizza: Solution to be evaluated

    Returns the number of satisfied customers
    """
    pizza.score = 0
    for client in pizza.customers:
        if ((client.likes_bitstring & pizza.solution) == client.likes_bitstring) and ((client.dislikes_bitstring & pizza.solution) == 0):
            pizza.score += 1
    return pizza.score

def get_neighbors(pizza):
    """
    Generates all neighbors of a given solution
    Neighbors are generated by adding or removing one ingredient from the solution

    Args:
        pizza: Current solution

    Returns a list of neighbors
    """
    neighbors = []

    # add ingredient
    for i in range(len(pizza.ingredients)):
        neighbor = Pizza(pizza.customers, pizza.ingredients)
        neighbor.solution = utils.enable_bit(pizza.solution, i)
        if neighbor.solution != pizza.solution:
            neighbors.append(neighbor)

    # remove ingredient
    for i in range(len(pizza.ingredients)):
        neighbor = Pizza(pizza.customers, pizza.ingredients)
        neighbor.solution = utils.disable_bit(pizza.solution, i)
        if neighbor.solution != pizza.solution:
            neighbors.append(neighbor)

    return neighbors

def get_best_neighbor(pizza, f):
    """
    Generates all neighbors of a given solution
    Neighbors are generated by adding or removing one ingredient from the solution

    Args:
        pizza: Current solution
        f: Evaluation function

    Returns the best neighbor found
    """

    best_neighbors = []
    best_score = -1
    for neighbor in get_neighbors(pizza):
        score = f(neighbor)
        if score > best_score:
            best_score = score
            best_neighbors = [neighbor]
        elif score == best_score:
            best_neighbors.append(neighbor)

    return random.choice(best_neighbors)

def hill_climbing(x0, f=eval_function, max_iterations=1000):
    """
    Hill climbing algorithm
    Stop criteria: `max_iterations` iterations without improvement

    Args:
        x0: initial solution
        f: evaluation function (default pizza.eval_function)
        max_iterations: maximum number of iterations with no improvement (default 1000)

    Returns the best solution found
    """
    x = x0 ; best_eval = f(x)

    it = 0 ; no_improvement = 0
    while no_improvement < max_iterations:
        it += 1 ; no_improvement += 1
        best_neighbor = get_best_neighbor(x, f)    # find neighbor with highest fitness value
        print(f"{it}: {x.get_solution()} -> {best_neighbor.get_solution()} ({best_neighbor.score})")
        neighbor_eval = f(best_neighbor)
        if neighbor_eval > best_eval:               # if the best neighbor is better than the current solution
            no_improvement = 0
            x = best_neighbor ; best_eval = neighbor_eval
            print(f"New best solution: {x.get_solution()} ({x.score})")

    return x # return the best solution found

def cooling_schedule(t):
    """
    Cooling schedule for the simulated annealing algorithm
    
    Args:
        t: Current temperature

    Returns the new temperature
    """
    return t * 0.999

def simulated_annealing(x0, f=eval_function, temperature=1000, max_iterations=1000):
    """
    Simulated annealing algorithm
    Stop criteria: `max_iterations` iterations without improvement

    Args:
        x0: initial solution
        f: evaluation function (default pizza.eval_function)
        temperature: initial temperature (default 1000)
        max_iterations: maximum number of iterations with no improvement (default 1000)

    Returns the best solution found
    """
    x = x0 ; curr_eval = f(x)

    it = 0 ; no_improvement = 0
    while no_improvement < max_iterations:
        it += 1 ; no_improvement += 1

        temperature = cooling_schedule(temperature)
        rand_neighbor = random.choice(get_neighbors(x)) ; neighbor_eval = f(rand_neighbor)
        print(f"{it}: {x.get_solution()} -> {rand_neighbor.get_solution()} ({rand_neighbor.score})")

        if neighbor_eval > curr_eval:             
            no_improvement = 0

            x = rand_neighbor ; curr_eval = neighbor_eval
            print(f"New best solution: {x.get_solution()} ({x.score})")
        else:
            chance = math.exp(-(curr_eval - neighbor_eval) / temperature) * 100
            prob = random.randint(1, 100)

            print(f"{chance}, {prob}")

            if prob <= chance:
                x = rand_neighbor ; curr_eval = neighbor_eval
                print(f"New worse solution: {x.get_solution()} ({x.score})")
    return x 

def roulette_wheel_selection(pizzas):
    """
    Roulette wheel selection method for genetic algorithm

    Args:
        pizzas: List of pizzas

    Returns two parents selected by the roulette wheel method
    """
    total_fitness = sum(pizza.score for pizza in pizzas)
    probabilities = [pizza.score / total_fitness for pizza in pizzas] if total_fitness != 0 else [1 / len(pizzas) for _ in pizzas]
    return random.choices(pizzas, weights=probabilities, k=2)

def tournament_selection(pizzas, num_p):
    """
    Tournament selection method for genetic algorithm

    Args:
        pizzas: List of pizzas
        num_p: Number of participants in the tournament

    Returns two parents selected by the tournament selection method
    """
    parents = []
    for _ in range(2):
        best_participant = None
        best_score = -1

        for _ in range(num_p):
            participant = random.choice(pizzas)
            if participant.score > best_score:
                best_participant = participant
                best_score = participant.score
        parents.append(best_participant)
    return parents

def genetic_algorithm(pizza, f=eval_function, num_generations=100, mutation_rate=0.01, selection_method="roulette", tournament_size=4):
    """
    Genetic algorithm for the pizza problem
    
    Args:
        pizza: Initial solution
        f: Evaluation function (default pizza.eval_function)
        num_generations: Number of generations (default 100)
        mutation_rate: Mutation rate (default 0.01)
        selection_method: Selection method (default roulette)
            - roulette: Roulette wheel selection
            - tournament: Tournament selection
        tournament_size: Tournament size (default 4)

    Returns the best solution found
    """
    if selection_method not in ["roulette", "tournament"]:
        raise ValueError("Invalid selection method")

    pizzas = get_neighbors(pizza)

    # missing termination criteria -> individual fit enough?
    for _ in range(num_generations):
        for pizza in pizzas:
            f(pizza)

        if selection_method == "roulette":
            parents = roulette_wheel_selection(pizzas)
        else:
            parents = tournament_selection(pizzas, tournament_size)

        children = crossover(parents)
        mutate(children, mutation_rate)

        pizzas += children
    pizzas.sort(key=f)
    return pizzas[-1]

def crossover(parents):
    """
    Crossover method for genetic algorithm

    Args:
        parents: List of two parents

    Returns two children generated by the crossover method
    """
    a = parents[0]
    b = parents[1]
    crossover_point = random.randint(1, min(len(bin(a.solution)), len(bin(b.solution))) - 1)

    # a and b's customers/ingredients should be the same, they're both used for diversity's sake
    child_1 = Pizza(a.customers, a.ingredients)
    child_2 = Pizza(b.customers, b.ingredients)

    child_1.solution = int(bin(a.solution)[:crossover_point] + bin(b.solution)[crossover_point:], 2)
    child_2.solution = int(bin(b.solution)[:crossover_point] + bin(a.solution)[crossover_point:], 2)
    return [child_1, child_2]

def mutate(children, mutation_rate):
    """
    Mutation method for genetic algorithm

    Args:
        children: List of children
        mutation_rate: Mutation rate

    Returns the mutated children
    """
    for child in children:
      for i in range(len(bin(child.solution))):
        if random.random() < mutation_rate:
          child.solution ^= utils.BIT(i)

def tabu_search(pizza, f=eval_function, max_iterations=1000, tabu_size=10, neighborhood_size=10):
    """
    Tabu search algorithm for the pizza problem

    Args:
        pizza: Initial solution
        f: Evaluation function (default pizza.eval_function)
        max_iterations: Maximum number of iterations (default 1000)
        tabu_size: Tabu list size (default 10)
        neighborhood_size: Size of the neighborhood (default 10)

    Returns the best solution found
    """
    # first score
    best_solution = pizza
    best_score = f(pizza)

    # current score
    current_solution = pizza
    tabu_list = []

    for _ in range(max_iterations):
        neighbors = get_neighbors_tabu(current_solution, neighborhood_size)
        best_neighbor = None
        best_neighbor_score = -float('inf')

        for neighbor in neighbors:
            # not on tabu or better
            if (neighbor.solution not in tabu_list) or (f(neighbor) > best_score):
                score = f(neighbor)
                if score > best_neighbor_score:
                    best_neighbor = neighbor
                    best_neighbor_score = score

        if best_neighbor is None:
            break

        current_solution = best_neighbor

        if best_neighbor_score > best_score:
            best_solution = best_neighbor
            best_score = best_neighbor_score

        tabu_list.append(best_neighbor.solution)
        if len(tabu_list) > tabu_size:
            tabu_list.pop(0)

    return best_solution

def generate_neighbor(pizza):
    """
    Generates a random neighbor of a given solution
    Only used in tabu search

    Args:
        pizza: Current solution

    Returns a random neighbor
    """
    new_solution = pizza.solution
    ingredient_index = random.randint(0, len(pizza.ingredients) - 1)

    # bit flip
    new_solution ^= utils.BIT(ingredient_index)

    # new pizza
    new_pizza = Pizza(pizza.customers, pizza.ingredients)
    new_pizza.solution = new_solution
    return new_pizza

def get_neighbors_tabu(pizza, neighborhood_size):
    """
    Generates a list of neighbors of a given solution
    Only used in tabu search

    Args:
        pizza: Current solution
        neighborhood_size: Size of the neighborhood
        
    Returns a list of neighbors
    """
    neighbors = []
    for _ in range(neighborhood_size):
        neighbor = generate_neighbor(pizza)
        neighbors.append(neighbor)
    return neighbors
