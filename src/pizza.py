import random
import utils

class Pizza:
    def __init__(self, customers, ingredients):
        self.customers = customers
        self.ingredients = ingredients
        # Generate a initial solution with random ingredients
        self.solution = random.randint(0, 2**len(ingredients) - 1)
        self.score = 0

    def get_solution(self):
        """
        Returns a set of ingredints that are in the solution
        TODO: Check if a list is more appropriate
        """
        return {self.ingredients[i] for i in range(len(self.ingredients)) if self.solution & utils.BIT(i)}
        

def eval_function(pizza): 
    """
    Evaluation function for the pizza problem
    pizza: Solution to be evaluated

    Returns the number of satisfied customers
    """
    pizza.score = 0
    for client in pizza.customers:
        # TODO: find a more efficient way to evaluate the solution without generating the set
        if ((client.likes & pizza.get_solution()) == client.likes) and ((client.dislikes & pizza.get_solution()) == set()):
            pizza.score += 1
    return pizza.score

def generate_neighbors(pizza):
    """
    Generates all neighbors of a given solution
    Neighbors are generated by adding or removing one ingredient from the solution
    pizza: Current solution

    Returns the list of neighbors of the given solution
    """
    neighbors = set()

    # add ingredient
    for i in range(len(pizza.ingredients)):
        neighbor = Pizza(pizza.customers, pizza.ingredients)
        neighbor.solution = utils.enable_bit(pizza.solution, i)
        if neighbor.solution != pizza.solution:
            neighbors.add(neighbor)

    # remove ingredient
    for i in range(len(pizza.ingredients)):
        neighbor = Pizza(pizza.customers, pizza.ingredients)
        neighbor.solution = utils.disable_bit(pizza.solution, i)
        neighbors.add(neighbor)
    
    return list(neighbors)
    
def hill_climbing(f, x0):
    """
    Hill climbing algorithm
    f: evaluation function
    x0: initial solution

    Returns the best solution found
    """
    x = x0

    while True:
        neighbors = generate_neighbors(x)       # generate current solution neighbors
        best_neighbor = max(neighbors, key=f)   # find neighbor with highest fitness value
        if f(best_neighbor) <= f(x):            # if the best neighbor is not better than the current solution, stop
            return x
        x = best_neighbor                       # otherwise, continue with the best neighbor
