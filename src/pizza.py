import random
import utils
import math
import random

class Pizza:
    def __init__(self, customers, ingredients):
        self.customers = customers
        self.ingredients = ingredients
        # Generate a initial solution with random ingredients
        self.solution = random.randint(0, 2**len(ingredients) - 1)
        self.score = 0

    def get_solution(self):
        """
        Returns a set of ingredints that are in the solution
        TODO: Check if a list is more appropriate
        """
        return {self.ingredients[i] for i in range(len(self.ingredients)) if self.solution & utils.BIT(i)}

def eval_function(pizza): 
    """
    Evaluation function for the pizza problem
    pizza: Solution to be evaluated

    Returns the number of satisfied customers
    """
    pizza.score = 0
    for client in pizza.customers:
        # TODO: find a more efficient way to evaluate the solution without generating the set
        if ((client.likes & pizza.get_solution()) == client.likes) and ((client.dislikes & pizza.get_solution()) == set()):
            pizza.score += 1
    return pizza.score

def get_best_neighbor(pizza, f):
    """
    Generates all neighbors of a given solution
    Neighbors are generated by adding or removing one ingredient from the solution
    pizza: Current solution
    f: Evaluation function

    Returns the best neighbor found
    """
    neighbors = set()

    # add ingredient
    for i in range(len(pizza.ingredients)):
        neighbor = Pizza(pizza.customers, pizza.ingredients)
        neighbor.solution = utils.enable_bit(pizza.solution, i)
        if neighbor.solution != pizza.solution:
            neighbors.add(neighbor)

    # remove ingredient
    for i in range(len(pizza.ingredients)):
        neighbor = Pizza(pizza.customers, pizza.ingredients)
        neighbor.solution = utils.disable_bit(pizza.solution, i)
        if neighbor.solution != pizza.solution:
            neighbors.add(neighbor)

    best_neighbors = []
    best_score = -1
    for neighbor in neighbors:
        score = f(neighbor)
        if score > best_score:
            best_score = score
            best_neighbors = [neighbor]
        elif score == best_score:
            best_neighbors.append(neighbor)

    return random.choice(best_neighbors)

def hill_climbing(f, x0):
    """
    Hill climbing algorithm
    Stop criteria: 1000 iterations without improvement
    f: evaluation function
    x0: initial solution

    Returns the best solution found
    """
    x = x0 ; best_eval = f(x)

    it = 0 ; no_improvement = 0
    while no_improvement < 1000:
        it += 1 ; no_improvement += 1
        best_neighbor = get_best_neighbor(x, f)    # find neighbor with highest fitness value
        print(f"{it}: {x.get_solution()} -> {best_neighbor.get_solution()} ({best_neighbor.score})")
        neighbor_eval = f(best_neighbor)
        if neighbor_eval > best_eval:               # if the best neighbor is better than the current solution
            no_improvement = 0
            x = best_neighbor ; best_eval = neighbor_eval
            print(f"New best solution: {x.get_solution()} ({x.score})")

    return x # return the best solution found

def get_random_neighbor(pizza, f):
    neighbors = set()

    # add ingredient
    for i in range(len(pizza.ingredients)):
        neighbor = Pizza(pizza.customers, pizza.ingredients)
        neighbor.solution = utils.enable_bit(pizza.solution, i)
        if neighbor.solution != pizza.solution:
            neighbors.add(neighbor)

    # remove ingredient
    for i in range(len(pizza.ingredients)):
        neighbor = Pizza(pizza.customers, pizza.ingredients)
        neighbor.solution = utils.disable_bit(pizza.solution, i)
        if neighbor.solution != pizza.solution:
            neighbors.add(neighbor)
    
    #for e in exclude:
    #    neighbors.remove(e)

    return random.choice(list(neighbors))

def cooling_schedule(t):
    return t * 0.999

def simulated_annealing(f, x0, temperature=1000):
    x = x0 ; curr_eval = f(x)
    # exclusion = set()

    it = 0 ; no_improvement = 0
    while no_improvement < 1000:
        it += 1 ; no_improvement += 1

        temperature = cooling_schedule(temperature)
        rand_neighbor = get_random_neighbor(x, f) ; neighbor_eval = f(rand_neighbor)
        print(f"{it}: {x.get_solution()} -> {rand_neighbor.get_solution()} ({rand_neighbor.score})")

        if neighbor_eval > curr_eval:             
            no_improvement = 0

            x = rand_neighbor ; curr_eval = neighbor_eval
            print(f"New best solution: {x.get_solution()} ({x.score})")
        else:
            chance = math.exp(-(curr_eval - neighbor_eval) / temperature) * 100
            prob = random.randint(1, 100)

            print(f"{chance}, {prob}")

            if prob <= chance:
                x = rand_neighbor ; curr_eval = neighbor_eval
                print(f"New worse solution: {x.get_solution()} ({x.score})")
            else:
                print(f"Skipped")
                # exclusion.add(rand_neighbor)
    return x 

def roulette_wheel_selection(pizzas):
    total_fitness = sum(pizza.score for pizza in pizzas)
    probabilities = [pizza.score / total_fitness for pizza in pizzas]
    return random.choices(pizzas, weights=probabilities, k=2)

def tournament_selection(pizzas, num_p):
    parents = []
    for _ in range(2):
        best_participant = None
        best_score = -1

        for _ in range(num_p):
            participant = random.choice(pizzas)
            if participant.score > best_score:
                best_participant = participant
                best_score = participant.score
        parents.append(best_participant)
    return parents

def genetic_algorithm(pizzas, num_generations, mutation_rate, selection_method="roulette", tournament_size=4):
    # missing termination criteria -> individual fit enough?
    for _ in range(num_generations):
        for pizza in pizzas:
            eval_function(pizza)

        if selection_method == "roulette":
            parents = roulette_wheel_selection(pizzas)
        elif selection_method == "tournament":
            parents = tournament_selection(pizzas, tournament_size)
        else:
            raise ValueError(f"Invalid selection method: {selection_method}")

        children = crossover(parents)
        mutate(children, mutation_rate)

        pizzas += children
    pizzas.sort(reverse=True, key=eval_function)
    return pizzas[0]

def crossover(parents):
    a = parents[0]
    b = parents[1]
    crossover_point = random.randint(1, min(len(bin(a.solution)), len(bin(b.solution))) - 1)

    # a and b's customers/ingredients should be the same, they're both used for diversity's sake
    child_1 = Pizza(a.customers, a.ingredients)
    child_2 = Pizza(b.customers, b.ingredients)

    child_1.solution = int(bin(a.solution)[:crossover_point] + bin(b.solution)[crossover_point:], 2)
    child_2.solution = int(bin(b.solution)[:crossover_point] + bin(a.solution)[crossover_point:], 2)
    return [child_1, child_2]

def mutate(children, mutation_rate):
    for child in children:
      for i in range(len(bin(child.solution))):
        if random.random() < mutation_rate:
          child.solution ^= utils.BIT(i)

def get_neightbors(pizza):
    neighbors = []

    # add ingredient
    for i in range(len(pizza.ingredients)):
        neighbor = Pizza(pizza.customers, pizza.ingredients)
        neighbor.solution = utils.enable_bit(pizza.solution, i)
        if neighbor.solution != pizza.solution:
            neighbors.append(neighbor)

    # remove ingredient
    for i in range(len(pizza.ingredients)):
        neighbor = Pizza(pizza.customers, pizza.ingredients)
        neighbor.solution = utils.disable_bit(pizza.solution, i)
        if neighbor.solution != pizza.solution:
            neighbors.append(neighbor)

    return neighbors
