import random
import utils
import math
import random

class Pizza:
    def __init__(self, customers, ingredients):
        self.customers = customers
        self.ingredients = ingredients
        # Generate a initial solution with random ingredients
        self.solution = random.randint(0, 2**len(ingredients) - 1)
        self.score = 0

    def get_solution(self):
        """
        Returns a set of ingredints that are in the solution
        TODO: Check if a list is more appropriate
        """
        return {self.ingredients[i] for i in range(len(self.ingredients)) if self.solution & utils.BIT(i)}

def eval_function(pizza): 
    """
    Evaluation function for the pizza problem
    pizza: Solution to be evaluated

    Returns the number of satisfied customers
    """
    pizza.score = 0
    for client in pizza.customers:
        # TODO: find a more efficient way to evaluate the solution without generating the set
        if ((client.likes & pizza.get_solution()) == client.likes) and ((client.dislikes & pizza.get_solution()) == set()):
            pizza.score += 1
    return pizza.score

def get_best_neighbor(pizza, f):
    """
    Generates all neighbors of a given solution
    Neighbors are generated by adding or removing one ingredient from the solution
    pizza: Current solution
    f: Evaluation function

    Returns the best neighbor found
    """
    neighbors = set()

    # add ingredient
    for i in range(len(pizza.ingredients)):
        neighbor = Pizza(pizza.customers, pizza.ingredients)
        neighbor.solution = utils.enable_bit(pizza.solution, i)
        if neighbor.solution != pizza.solution:
            neighbors.add(neighbor)

    # remove ingredient
    for i in range(len(pizza.ingredients)):
        neighbor = Pizza(pizza.customers, pizza.ingredients)
        neighbor.solution = utils.disable_bit(pizza.solution, i)
        if neighbor.solution != pizza.solution:
            neighbors.add(neighbor)

    best_neighbors = []
    best_score = -1
    for neighbor in neighbors:
        score = f(neighbor)
        if score > best_score:
            best_score = score
            best_neighbors = [neighbor]
        elif score == best_score:
            best_neighbors.append(neighbor)

    return random.choice(best_neighbors)

def hill_climbing(f, x0):
    """
    Hill climbing algorithm
    Stop criteria: 1000 iterations without improvement
    f: evaluation function
    x0: initial solution

    Returns the best solution found
    """
    x = x0 ; best_eval = f(x)

    it = 0 ; no_improvement = 0
    while no_improvement < 1000:
        it += 1 ; no_improvement += 1
        best_neighbor = get_best_neighbor(x, f)    # find neighbor with highest fitness value
        print(f"{it}: {x.get_solution()} -> {best_neighbor.get_solution()} ({best_neighbor.score})")
        neighbor_eval = f(best_neighbor)
        if neighbor_eval > best_eval:               # if the best neighbor is better than the current solution
            no_improvement = 0
            x = best_neighbor ; best_eval = neighbor_eval
            print(f"New best solution: {x.get_solution()} ({x.score})")

    return x # return the best solution found

def get_random_neighbor(pizza, f):
    neighbors = set()

    # add ingredient
    for i in range(len(pizza.ingredients)):
        neighbor = Pizza(pizza.customers, pizza.ingredients)
        neighbor.solution = utils.enable_bit(pizza.solution, i)
        if neighbor.solution != pizza.solution:
            neighbors.add(neighbor)

    # remove ingredient
    for i in range(len(pizza.ingredients)):
        neighbor = Pizza(pizza.customers, pizza.ingredients)
        neighbor.solution = utils.disable_bit(pizza.solution, i)
        if neighbor.solution != pizza.solution:
            neighbors.add(neighbor)
    
    #for e in exclude:
    #    neighbors.remove(e)

    return random.choice(list(neighbors))

def cooling_schedule(t):
    return t * 0.999

def simulated_annealing(f, x0, temperature=1000):
    x = x0 ; curr_eval = f(x)
    # exclusion = set()

    it = 0 ; no_improvement = 0
    while no_improvement < 1000:
        it += 1 ; no_improvement += 1

        temperature = cooling_schedule(temperature)
        rand_neighbor = get_random_neighbor(x, f) ; neighbor_eval = f(rand_neighbor)
        print(f"{it}: {x.get_solution()} -> {rand_neighbor.get_solution()} ({rand_neighbor.score})")

        if neighbor_eval > curr_eval:             
            no_improvement = 0

            x = rand_neighbor ; curr_eval = neighbor_eval
            print(f"New best solution: {x.get_solution()} ({x.score})")
        else:
            chance = math.exp(-(curr_eval - neighbor_eval) / temperature) * 100
            prob = random.randint(1, 100)

            print(f"{chance}, {prob}")

            if prob <= chance:
                x = rand_neighbor ; curr_eval = neighbor_eval
                print(f"New worse solution: {x.get_solution()} ({x.score})")
            else:
                print(f"Skipped")
                # exclusion.add(rand_neighbor)
    return x 
